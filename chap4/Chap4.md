## 상속 관계 - 어떻게 클래스를 상속하거나 인터페이스를 구현하는가

### 임포터

다양한 종류의 문서를 임포트하는 방법

- switch문 -> 확장성이 부족하다.
- => 다양한 문서를 임포트하는 **클래스로 분리**하면, 각각의 임포트 동작을 따로 처리하므로 찾기 쉽고, 이해하기 쉬운 코드를 만들 수 있다.

먼저 Importer 인터페이스 정의 -> Importer 인터페이스를 구현하는 각 클래스는 다양한 종류의 파일을 임포트한다.

임포트하려는 파일 표현

1. 파일 경로를 단순히 String으로 표현❌
2. 파일을 가리키는 클래스를 사용하는 방법⭕️

=> **강한 형식(String Type)의 원칙** 적용 : String 대신 파일을 가리키는 전용 형식을 이용하여 오류가 발생할 범위를 줄인다.

### Document 클래스

문서의 종류에 따라 포함하는 속성이 달라진다.

방법 1 : Map<String, String>으로 속성 이름을 값과 매핑하는 방법

- 응용프로그램에 직접 사용하지 않는다. 유지보수성과 가독성 고려하지 않는 방법이다.

**강한 형식을 이용**하면 데이터의 사용 방법을 규제할 수 있다. 

- Document 클래스는 불변 클래스 - 클래스를 생성한 다음에는 클래스의 속성을 바꿀 수 없다.
- Importer 구현이 문서를 만들면 이후에 수정할 수 없다.

그에 따른 이득으로,

- Document 속성에서 오류가 발생하면 해당 Document를 생성한 Importer 구현을 확인하면 되므로 오류 발생 원인을 좁힐 수 있다.
- Document 불변성 덕분에 안전하게 Document로 색인을 만들거나 Document 정보를 캐시할 수 있다.

방법 2 : Document가 HashMap<String, String>을 상속받도록 설계하는 방법

- 소프트웨어를 설계할 때 필요한 기능은 추가하면서 동시에 불필요한 기능은 제한해야한다. -> 상속 받으면 그렇게 할 수 없다.
- 불변성으로 얻을 수 있는 모든 이득이 사라진다.

=> **도메인 클래스를 이용**하면 개념에 이름을 붙이고 수행할 수 있는 동작과 값을 제한하므로 발견성을 개선하고 버그 발생 범위를 줄일 수 있다.



## 리스코프 치환 원칙(LSP)

상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다는 원칙

클래스 상속과 인터페이스 구현을 올바르게 사용하도록 도와준다.

- 하위형식에서 선행조건을 더할 수 없음

  - 부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없음을 의미한다.

  > 선행조건은 어떤 코드가 동작하는 조건을 결정한다.

- 하위형식에서 후행조건을 약화시킬 수 없음

  - 부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 그래야 한다.

  > 후행조건은 어떤 코드를 실행한 다음에 만족해야 하는 규칙이다.

- 슈퍼형식의 불변자는 하위형식에서 보존됨

  - 부모 클래스에서 유지되는 모든 불변자는 자식 클래스에서도 유지되어야 한다.

- 히스토리 규칙

  - 자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않아야 한다.



## 다른 설계 (다른 관점)

### 임포터를 클래스로 만들기

임포터의 클래스 계층을 만들고 인터페이스 대신 가장 상위에 Importer 클래스를 만드는 방법

- 쉽게 망가질 수 있는 상속 기반의 클래스를 피해야 한다. -> 인터페이스를 이용하는 것이 클래스를 이용하는 것보다 명백하게 좋은 선택이다.
- 문제를 해결하려는 도메인에 상태와 많은 동작이 관련되어 있어서 강력한 **is a 관계**를 모델링해야 하는 상황이라면 **클래스 기반 상속**이 더 적절하다.

### 영역, 캡슐화 선택하기

패키지 영역을 이용해 캡슐화를 구현할 수 있다.

- 클래스가 외부로 노출되지 않도록 패키지 영역을 적극적으로 적용하면 내부 설계를 쉽게 바꿀 수 있다.
- 실제 소프트웨어를 개발할 때는 패키지 영역보다 공개(public) 영역을 더 많이 사용한다. 공개 영역을 기본으로 설정하는 것이 더 좋은 결정일 수도 있다.



## 기존 코드 확장과 재사용

제품에 기능을 추가하거나, 고객의 요구 사항이 바뀌거나, 법규가 제정되면서 소프트웨어를 어쩔 수 없이 변경해야 한다.

코드를 재사용하려면 해당 코드를 어떤 클래스에 구현해야 한다.

1. 유틸리티 클래스 사용
   - 여러 임포트에서 공유해야 하는 기능을 이 유틸리티 클래스에 구현한다.
   - 유틸리티 클래스는 여러 정적 메서드를 포함한다.
   - 객체지향 프로그래밍의 지향점과는 거리가 멀다.
   - 어떤 한 의무나 개념과 상관없는 다양한 코드의 모음으로 귀결된다. -> 갓 클래스 모양 (안티 패턴)
2. 상속 사용
   - 동작과 개념 연결
   - **실제 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있다**는 문제점이 있다.
   - 변화를 추상화하는 것이 더 좋다.
3. 도메인 클래스 사용
   - 기본 개념을 모델링한 다음, 기본 개념이 제공하는 메서드를 호출해 다양한 임포터를 만든다.
   - 기본 개념 - 새롭거나 창의적이지 않다는 점이 핵심이다.
   - 클래스 이름이 매우 단순 명료 -> 조작하는 함수를 어디에 추가할지 쉽게 알 수 있다.

=> 도메인 클래스를 이용하면 유연성을 개선할 수 있다.

=> 도매인 클래스를 이용하면 상속 같이 쉽게 깨질 수 있는 계층을 만들지 않으면서도 코드를 재사용할 수 있다.



## 테스트 위생

테스트 대상 코드베이스뿐 아니라 테스트 코드도 깔끔하게 유지하며 유지보수하고 개선해야 함을 의미한다.

- 도메인 용어 사용 / 자연어 사용 / 서술적 으로 테스트 이름을 짓는다.

- 클래스, 컴포넌트, 시스템 테스트를 구현할 때는 대상의 공개 동작(public behavior)만 테스트한다.
- 객체의 내부 상태나 설계는 고려하지 않고 오직 공계 API 메서드만 이용해 테스트를 수행해야 한다.

- 테스트 코드의 중복 코드는 크게 신경 쓰지 않는다.

- 실패에 최적화된 테스트를 구현하는 것이 좋다. 테스트가 실패한 이유를 쉽게 이해할 수 있도록 만들어야 한다.
- 테스트가 실패했을 때 출력하는 메시지와 정보 -> 매처(matcher)로 컬렉션 크기를 확인하는 방법(Hamcrest 자바 라이브러리)

- 중요하며, 잘 동작하도록 예상된 경로만 검증하지 않는다.
- static final로 상수를 표현한다. 상수에도 테스트에 활용되는 용도에 따라 적절할 이름을 붙인다.
