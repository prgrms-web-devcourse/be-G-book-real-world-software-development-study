# chapter 4 문서 관리 시스템 

### 📌 `리스코프 치환 원칙(LSP)` `강한 형식의 원칙` `확장과 재사용`

---

<br/>

---

## # 설계 작업

### # 임포터
> 다양한 종류의 문서를 임포트하는 것 = 문서 관리 시스템의 핵심 기능

- switch문은 확장성이 부족
- 다양한 문서를 임포트하는 클래스로 분리하여 각각의 임포트 동작을 따로 처리하도록,
- `Importer` 인터페이스 정의 → 다양한 종류의 문서 임포트를 지원

```java
import java.io.IOException;

interface Importer {
    Document importFile(File file) throws IOException;
}
```

### # 강한 형식의 원칙
- 강한 형식을 이용하면 데이터의 사용 방법을 규제할 수 있음 
- 도메인 클래스를 이용하면 개념에 이름을 붙이고 수행할 수 있는 동작과 값을 제한하므로 발경성을 개선하고 버그 발생 범위를 줄일 수 있음
- <details markdown="1">
  <summary> ex. </summary>
    다양한 문서를 임포트하는 부분을 Importer 인터페이스로 분리, Document 클래스(불변)는 클래스를 생성한 다음에는 클래스의 속성을 바꿀 수 없다. <br/>
    Importer 구현이 문서를 만들면 이후에 수정할 수 없다. 따라서 Document의 속성에서 오류가 발생하면 Importer 구현을 확인하면 되므로 오류가 발 <br/>
    생한 원인을 좁힐 수 있다. Document의 불변성 덕분에 안전하게 Document로 색인을 만들거나 Document 정보를 캐시할 수 있다.
  </details>

<br/>

---

## # 리스코프 치환 원칙
> _**LSP(Single Responsibility Principle)** : 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다._

- 쉽게 말해, 특정 메서드가 상위 타입을 인자로 사용한다고 할 때, 그 타입의 하위 타입도 문제 없이 정상적으로 작동을 해야 한다는 것
- _LSP q(x) 는 T 형식의 x객체를 증명할 수 있는 공식, S 형식의 객체 y가 있고 S가 T의 하위형식이라면 q(y)는 참_

#

### # 하위타입에서 선행조건을 더할 수 없음 
- 선행조건은 어떤 코드가 동작하는 조건을 결정한다.
- 우리는 구현한 코드가 어떻게든 실행될 것이라고 가정할 수 없다
- 부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없음을 의미한다.

### # 하위타입에서 후행조건을 악화시킬 수 없음
- 후행조건은 어떤 코드를 실행한 다음에 만족해야 하는 규칙이다.
- 부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 그래야 한다.

### # 상위타입의 불변자는 하위형식에서 보존됨 
- (불변자란 항상 변하지 않는 어떤 것)
- 상속 관계의 부모와 자식 클래스가 있을 때, 부모 클래스에서 유지되는 모두 불변자는 자식 클래스에서도 유지되어야 한다.

### # 히스토리 규칙
- 기본적으로 자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않아야 한다.
- 부모 클래스(불변)를 인스턴스화한 다음에는 어떤 속성도 삭제, 추가, 변경할 수 없다.

<br/>

---

## # 기존 코드 확장과 재사용
> 코드를 재사용하기 위한 세 가지 방법


### # 유틸리티 클래스 사용 
- 여러 임포트에서 공유해야 하는 기능을 이 유틸리티 클래스에 구현, 여러 정적 메서드 포함 
- 유틸리티 클래스는 여러 의무를 담당하는 갓 클래스의 모양을 가지게 된다. 

### # 상속 사용
- 상속을 이용하여 동작과 개념을 연결할 수 있다.
- 실제 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있다는 점이 단점이다.


### # 도메인 클래 사용
- 기본 개념을 모델링한 다음, 기본 개념이 제공하는 메서드를 호출하여 다양한 임포터를 만든다.
- 도메인 클래스를 이용하면 상속 처럼 쉽게 깨질 수 있는 계층을 만들지 않으면서도 코드를 재사용할 수 있다.

<br/>

---

## # 테스트 위생 
> 테스트 대상 코드베이스뿐만 아니라 테스트 코드도 깔끔하게 유지하며 유지보수하고 개선해야함

<br/>

_**테스트 위생을 지키는 여러 핵심 요소**_

### # 테스트 이름 짓기 
- 테스트 이름을 지을 때 가독성, 유지보수성, 실행할 수 있는 문서의 역할 고려하기
- 개념이나 명사로 테스트의 이름으로 결정하지 않기, 실행하는 메서드명 그대로 사용하지 않기
- 도메인 용어 또는 자연어 사용, 서술적으로 표현 

→ 즉, 이름만으로 어떤 기능이 동작하고 하지 않는지 알 수 있어야 한다.

### # 구현이 아닌 동작
- 대상의 공개 동작만 테스트
- 객체의 내부 상태나 설계는 고려하지 않고 오직 공개 API 메서드만 이용하여 테스트를 수행

### # 중복 배제 
- 테스트 코드에서도 중복된 코드를 최대한 제거하기 

### # 좋은 진단
- 실패에 최적화된 테스트를 구현하기 (테스트가 싫패한 이유를 쉽게 이해할 수 있도록) 
- `assertTrue()`: 참일 것으로 예상되는 불리언 값을 인수로 받음
- `assertEquals()`: 두 개의 값을 받아 이들이 같은지 비교 
- `assertThat()`: 첫 번째 인수에 값을 받고 두 번째 인수로 Matcher를 받음 
  - Matcher는 값이 어떤 속성과 일치하는지와 관련 진단을 캡슐화

### # 오류 상황 테스트  
- 제이유닛 `@Test` 의 expected = 속성을 사용해 어서션 추가
  - '이 테스트는 이런 종류의 예외를 던질거다' 라는 의미 

### # 상수
- 상수에도 테스트에 활용되는 용도에 따라 적절한 이름을 붙이는 것이 좋음