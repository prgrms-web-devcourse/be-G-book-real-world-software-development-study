# Chapter 4. 문서 관리 시스템



## 4.1 목표

- LSP(리스코프 치환 원칙)
- 테스트 위생





## 4.2 요구 사항

> 문서 관리 시스템(환자 정보 파일을 읽어 색인을 추가하고 검색할 수 있는 형태)

- 리포트
- 우편물
- 이미지





## 4.3 설계 작업

**4.3.1 임포터**

- switch문은 확장성이 부족하다.
- 다양한 문서를 임포트하는 클래스로 분리하면, 각각의 임포트 동작을 따로 처리해 찾기 쉽고, 이해하기 쉬운 코드를 만들 수 있다.
- Importer 인터페이스를 사용해 다양한 종류의 문서(확장자)를 임포트한다.
- 단순히 String으로 표현하기 보다는 **강한 형식 원칙**을 적용해 파일 표현하기
  - 파일을 가리키는 File 객체를 사용해 오류 발생 범위를 줄인다.

```java
interface Importer {
	Document importFile(File file) throws IOException;
}
```

- 클래스 계층으로 인한 이득이 없다면 계층을 추가할 필요가 없다. -> 단순할수록 좋다.



**4.3.2 Document 클래스**

> 각 문서의 종류에 따라 포함하는 속성이 달라진다.

**Map<String, String>으로 속성 이름을 값과 매핑**

- 유지보수성과 가독성을 고려하지 않은 방법이기 때문에 프로그램에 직접 사용하지 않는다.



**강한 형식**을 이용해 데이터 사용방법을 규제할 수 있다.

- Document 클래스는 불변 클래스로 속성을 바꿀 수 없다. 
- Importer 구현이 문서를 만들면 이후에 수정할 수 없다.

- 오류 발생 원인을 좁히거나 안전하게 정보를 캐시할 수 있다.

  

**HashMap<String, String>을 상속받음**

- SW 설계시 필요한 기능은 추가, 불필요한 기능은 제한한다.

- 하지만, 상속을 받으면 불변성으로 얻을 수 있는 모든 이득이 사라진다. 

  

**도메인 클래스를 사용해 수행할 수 있는 동작과 값을 제한해 발견성을 개선하고 버그 발생 범위를 줄일 수 있다.**





## 4.4 리스코프 치환 원칙(LSP)

> 자식 클래스는 부모로부터 물려받은 행동을 유지해야 한다.

1. 하위형식에서 선행조건을 더할 수 없다.

   - 부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없다.
   - 선행조건 : 어떤 코드가 동작하는 조건을 결정

   

2. 하위형식에서 후행조건을 약화시킬 수 없다.

   - 부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 그래야 한다.

   

3. 슈퍼형식의 불변자는 하위형식에서 보존된다.

   - 부모 클래스에서 유지되는 모든 불변자는 자식 클래스에서도 유지되어야 한다.

   

4. 히스토리 규칙

   - 자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않아야 한다. 
   - ex) 삭제 등의 기능을 추가할 수 없다.





## 4.5 대안

1. 임포터를 클래스로 만들기
   - 쉽게 망가질 수 있는 상속 기반의 클래스를 피해야 한다.
   - 순수한 **is a 관계**일 때만 클래스 기반의 상속이 적절하다.
   - *is a : 일반클래스를 구체화하는 상황에서 상속을 사용하는 것.*



2. 영역, 캡슐화
   - 패키지 영역을 활용해 캡슐화를 구현
   - 패키지 영역을 활용해 클래스가 외부로 노출되지 않는다면 내부 설계를 쉽게 바꿀 수 있다.





## 4.6 기존 코드 확장과 재사용

> 하나의 코드를 세 개의 임포트에 재사용하기 위한 방법

1. 유틸리티 클래스 사용

   - 유틸리티 클래스에 임포트에서 공유해야 하는 기능을 구현
   - 갓 클래스가 생겨난다.

   

2. 상속 사용

   - 한 클래스에 모든 공통 기능을 구현하고, 서브클래스에서 공통 기능을 재사용한다.
   - 실제 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있기 때문에 일반적으로 상속으로 인한 재사용은 좋은 방법이 아니다.

   

3. 도메인 클래스 사용

   - 쉽게 깨지지 않는 계층을 만들면서 코드를 재사용할 수 있다.
   - 유연성을 개선할 수 있다.
   - 쉽게 깨지지 않는 계층을 만들면서 코드를 재사용할 수 있다.





## 4.7 테스트 위생

**자동화된 테스트** 

- 퇴행이 발생하는 범위를 줄인다.
- 어떤 동작이 문제를 일으켰는지 이해할 수 있도록 도와준다.
- 자신 있게 코드를 리팩토링할 수 있다.



*하지만, 코드를 많이 구현해보고 유지보수해야 좋은 테스트가 된다. 이를 위해 테스트 위생을 지켜야 한다. 기존 코드와 **테스트 코드도 깔끔하게 유지하고 유지보수**해야 한다.*



1. 테스트 이름 짓기

   - 가독성, 유지보수성, 실행할 수 있는 문서의 역할을 고려해 이름 짓기
   - 테스트하는 동작을 묘사해야 한다.
   - 도메인 용어를 사용하거나, 자연어를 사용하거나, 서술적으로 이름을 지어야 한다.

   

2. 구현이 아닌 동작

   - 대상의 공개 동작만 테스트한다.

   

3. 중복 배제

   - 기존코드와 마찬가지로 테스트 코드도 중복을 최대한 배제해야 한다.

   

4. 좋은 진단(테스트가 실패했을 때 출력하는 메시지와 정보)

   - 실패에 최적화된 테스트를 구현해야 한다.
   - 이때, 테스트가 실패한 이유를 쉽게 이해할 수 있도록 만들어야 한다.
   - 매처로 컬렉션 크기를 확인하거나, assertion을 새로 구현해 진단 결과를 확인할 수 있다.

   ```java
   private void assertAttributeEquals(
               final Document document,
               final String attributeName,
               final String expectedValue)
   {
       assertEquals(
               "Document has the wrong value for " + attributeName,
               expectedValue,
               document.getAttribute(attributeName));
   }
   ```

   

5. 오류 상황 테스트

   - 예상된 경로만 검증하는 것이 아니라 다양한 상황을 생각하고 테스트해야 한다.

   

6. 상수

   - 용도에 따라 적절한 이름을 붙여야 한다.

