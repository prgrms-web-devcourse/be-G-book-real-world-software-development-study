# Chapter 3. 입출금 내역 분석기 확장판



## 3.1 목표

- OCP(개방/폐쇄 원칙) 적용
- 인터페이스 가이드라인
- 자바 예외 처리
- 빌드 도구 사용





## 3.2 요구 사항

1. 특정 입출금 내역을 검색할 수 있는 기능
2. 검색 결과의 요약 통계를 다양한 형식으로 만들기





## 3.3 OCP(개방/폐쇄) 원칙

- 한 메소드에 요구사항을 모두 구현하면 코드가 중복되고 복잡해진다.
  - *중복 코드 : 요구 사항이 자주 바뀔수록 SW를 불안정하게 만든다.*
- OCP는 이러한 경우 코드를 **직접 바꾸지 않고** 해당 메소드나 클래스의 **동작을 바꿀 수 있다.**

- 비즈니스 로직을 담당하는 인터페이스를 사용해 반복 로직과 비즈니스 로직의 **결합을 제거**한다.
- 아래 인터페이스를 선언함으로써 새로운 구현을 인수로 전달하기 때문에 **확장성이 개방**된다.

> BankTransactionFilter 인터페이스

```java
@FunctionalInterface
public interface BankTransactionFilter {
	boolean test(BankTransaction bankTransaction);
}
```



**3.3.1 OCP의 장점**

- 기존 코드를 바꾸지 않아도 되기때문에 기존 코드가 잘못될 가능성이 줄어든다.
- 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
- 결합도가 낮아지기 때문에 코드 유지보수성이 좋아진다.



**3.3.2 람다 표현식**

- 매번 별도의 클래스를 만들지 말고 람다를 사용하자.

- 자바 8 이상부터 람다 표현식 사용이 가능하다.
- 이름 없이 **인터페이스 구현 객체를 코드 블록 형태로 전달**할 수 있다.

> BankTransactionFilter 람다로 구현

```java
final List<BankTransaction> transactions 
	= bankStatementProcessor.findTransactions(bankTransaction ->
			bankTransaction.getDate().getMonth() == Month.FEBRUARY
			&& bankTransaction.getAmount() >= 1_000);
```





## 3.4 인터페이스 문제

**3.4.1 갓 인터페이스**

- 한 곳에 모든 기능이 추가된 인터페이스
- 모든 연산을 담당해 **유지보수가 힘들고**, **결합이 발생할 수 있다.**
- 작은 인터페이스로 구분해야 도메인 객체를 활용해 의존도를 최소화시킬 수 있다.

- 갓 인터페이스와 반대로 **지나치게 세밀한 인터페이스**도 **안티 응집도가 발생**해 인터페이스가 계속 추가되어 **복잡도가 높아진다**.





## 3.5 명시적 API vs 암시적 API

- *명시적 API : 어떤 동작을 수행하는지 잘 설명되어 있고, 사용하기 쉽다. 하지만, 상황에 맞는 새로운 메소드를 많이 만들어야 한다.*

- *암시적 API : 해당 기능이 필요한 모든 상황을 처리할 수 있다. 하지만, 처음 사용하기 어렵고 문서화가 필요하다.*

- 각 상황에 따라 맞는 방법을 선택해야 한다.



3.5.1 원싯값

- double, int 등의 원싯값을 결과로 반환시키면 다양한 결과를 반환할 수 없어 **유연성이 떨어진다.**



3.5.2 도메인 클래스

- 필요한 **필드와 결과를 언제든 추가**할 수 있다.
- **결합을 줄이고**, 수정시 **연쇄적으로 코드가 바뀌는 일도 최소화**시킬 수 있다.





## 3.6 다양한 형식으로 내보내기

**3.6.1 도메인 객체**

(1) 숫자

- 간단하게 구현할 수 있지만, 반환 타입을 지정하면 요구 사항이 바뀔 때 유연하게 대처할 수 없다.



(2) 컬렉션

- 유연성을 높일 수 있지만, 오직 컬렉션만 반환할 수 있어 고민이 필요하다.



(3) 도메인 객체

- 요구 사항이 추가로 생기면 기존 코드 수정 필요 없이 새로운 클래스의 일부로 구현 할 수 있다.



**3.6.2 인터페이스 메소드 반환 형식**

- void는 무엇을 반환하는지 알 수 없어, 도움이 되지 않는다.
- 또한, 테스트하기 어렵다.
- 만약 String을 반환하면 Assertion으로 테스트할 수 있다.





## 3.7 예외 처리

(1) 사용해야 하는 이유

- 문서화(메소드 시그니처 자체에 예외 지원)
- 형식 안전성(예외 흐름 처리 여부를 시스템이 파악)
- 관심사 분리(비즈니스 로직과 예외 회복이 구분됨)



*확인된 예외 : 회복해야 하는 대상의 예외. 해당 예외 목록을 선언하거나 try/catch 처리해야 한다.*

*미확인 예외 : 언제든 발생할 수 있는 예외. 오류를 선언하지 않으면 꼭 처리할 필요 없다.*



3.7.1 노티피케이션(Notification) 패턴

- 너무 많은 미확인 예외를 사용하는 상황에 해결책을 제공한다.
- 도메인 클래스로 오류를 수집한다.

> Notification.class

```
public class Notification {
	public final List<String> errors = new ArrayList<>();
	
	public void addError(final String message) {
		errors.add(message);
	}
	public boolean hasErrors() {
		return !errors.isEmpty();
	}
	public String errorMessage() {
		return errors.toString();
	}
	public List<String> getErrors() {
		return this.errors;
	}
}
```



3.7.2 예외 사용 가이드라인

(1) 예외를 무시하지 않는다.

(2) 일반적인 예외는 잡지 않는다.

(3) 예외를 문서화한다.

(4) 특정 구현에 종속된 예외를 주의해야 한다.



3.7.3 예외 대안 가능

(1) null 사용

- 오류가 쉽게 발생하니 **<u>null은 절대 반환하지 말자!</u>**



(2) null 객체 패턴

- 의도하지 않은 NPE과 긴 null 확인 코드를 피할 수 있지만, 데이터에 문제가 있어니 무시할 수 있다.



(3) Optional<T>

- 값이 없는 상태를 명시적으로 처리한다.



(4) Try<T>

- 연산에서 발생하는 오류 범위를 줄여준다.





## 3.8 빌드 도구

3.8.1 사용 이유

- SW 개발 생명 주기를 자동화한다.
- 공통적인 구조를 제공해 동료가 편안하게 프로젝트를 받아들인다.
- 프로그램을 빌드하고 실행하는 작업을 설정한다.
- 시간을 절약할 수 있다.
- 오류 범위를 줄인다.



3.8.2 메이븐

- 유지보수에 도움이 되는 구조를 제공한다.
- pom.xml 파일에 빌드 프로세스를 정의한다.

- 가독성이 떨어지고 작업이 귀찮다.
- 유지보수 부담을 증가시킨다.



3.8.3 그레이들

- 도메인 특화 언어를 적용해 자연스럽게 빌드를 지정하고, 쉽게 커스터마이징할 수 있다.
- 빌드 시간을 단축한다.
- 메이븐보다 훨씬 간결하다.

