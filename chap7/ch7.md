## 영구 저장과 저장소 패턴

- 도메인 로직과 저장소 백엔드 간의 인터페이스를 정의한다. 
- 저장소 패턴을 이용하면 응용프로그램의 저장소를 다른 저장소 백엔드로 쉽게 갈아탈 수 있다.

**저장소 패턴의 장점**

- 저장소 백엔드를 도메인 모델 데이터로 매핑하는 로직을 중앙화(centralize)함
- 실제 데터베이스 없이도 코어 비즈니스 로직을 유닛 테스트하므로 빠르게 테스트를 실행할 수 있음
- 각 클래스가 하나의 책임을 가지므로 유지보수성과 가독성이 좋아짐

설계에서 주의할 점 : YAGNI(You aren't gonna ned it) - 미래에 사용할 것 같은 기능은 구현하지 말고 정말로 사용해야 할 때 그 기능을 구현한다.

고유 객체를 만드는 일을 **데이터 계층**에 위임한다.

### 저장소 설계

- 제네릭 인터페이스로 저장소 패턴을 구현
  -> 다양한 저장소를 추상화할 수 있다. 하지만 단지 저장소라는 이유로 한 인터페이스를 구현하도록 강요한다면 좋은 추상화 설계라고 볼 수 없다.

### 쿼리 객체

다양한 쿼리 기능 구현 방법

1. 자바 컬렉션처럼 구현
   - 구현은 단순하지만, 속도가 현저히 느릴 가능성이 크다.
   - :white_check_mark:**SQL 데이터베이스 같은 데이터 저장소 백엔드** - 최적화가 잘 되어 있고 데이터 쿼리와 정렬 기능의 효율성이 높다.

2. 쿼리 수행 비즈니스 로직에 대응하는 메서드를 추가하는 방법

   - 특정 비즈니스 로직 기능이 저장소 구현과 결합되는 단점이 있다.
   - 요구 사항이 바뀌면 코어 도메인 로직뿐만 아니라 저장소도 바꿔야 하므로 구현을 바꾸기가 어려우며 단일 책임 원칙에도 위배된다.

   ```java
   List<Twoot> twootForLogon(User user);
   ```

3. 비즈니스 조건으로 저장소를 쿼리하는 메서드를 추가하는 방법 

   - 시간이 지나면서 더 다양한 쿼리 기능이 필요한데, 각 쿼리를 메서드로 하드코딩한다면 저장소에 더 많은 메서드를 추가해야 하므로 코드가 거대해지고 이해하기 어려워진다.

   ```java
   List<Twoot> twootsFromUsersAfterPosition(Set<String> inUsers, Position lastSeenPosition);
   ```

4. 쿼리할 조건을 객체 안에 추상화

   - 메서드를 추가할 필요 없이 이 메서드 하나의 다양한 추가 속성으로 쿼리를 수행할 수 있다.

   ```java
   public interface TwootRepository {
     List<Twoot> query(TwootQuery query);
   }
   
   public class TwootQuery {
     private Set<String> inUsers;
     private Position lastSeenPosition;
   
     public Set<String> getInUsers() { 
       return inUsers;
     }
   
     public Position getLastSeenPosition() {
       return lastSeenPosition;
     }
   
     public TwootQuery inUsers(final Set<String> inUsers) {
       this.inUsers = inUsers;
       
       return this;
     }
   
     public TwootQuery inUsers(String... inUsers) {
       return inUsers(new HashSet<>(Arrays.asList(inUsers)));
     }
   
     public TwootQuery lastSeenPosition(final Position lastSeenPosition) {
       this.lastSeenPosition = lastSeenPosition;
       
       return this;
     }
   
     public boolean hasUsers() {
       return inUsers != null && !inUsers.isEmpty();
     }
   }
   ```

   - 객체 List를 반환한다는 것은 모든 Twoot 객체를 메모리에 저장해 한 번에 처리함을 의미한다. -> List의 크기가 매우 클 수 있으므로 좋은 방법이 아니다.
   - 모든 객체의 쿼리를 반드시 한 번에 완료해야 하는 상황이 아닐 수도 있다.
   - 모든 Twoot 객체를 메모리에 저장하는 대신 각 객체를 UI로 푸시해 이 문제를 해결할 수 있다.
   - 일부 저장소는 반환된 결과 집합을 모델링하는 객체를 갖도록 구현한다. -> 객체를 이용해 페이지를 바꾸거나 반복하면서 값을 확인한다.

5. 함수형 인터페이스 `Counsumer<Twoot>` 콜백 이용

6. - 한 개의 인수를 받아 void 반환
   - 람다 표현식이나 메서드 레퍼런스로 구현

   ```java
   public interface TwootRepository {
     void query(TwootQuery twootQuery, Consumer<Twoot> callback);
   }
   
   twootRepository.query(
   	new TwootQuery()
     	.inUsers(user.getFollowing())
     	.lastSeenPosition(user.getLastSeenPosition()),
     user::receiveTwoot
   )
   ```

저장소 구현 기법 중 **작업 단위(Unit of Work) 패턴**

- 데이터베이스는 ACID를 준수하도록 트랜잭션을 구현한다.
- 데이터베이스 트랜잭션이 원활하게 수행되도록 돕는 디자인 패턴이다.
- 저장소에 수행하는 모든 연산은 작업 단위 객체로 등록된다.
- 작업 단위 객체(필요한 연산을 트랜잭션으로 감싸는)를 한 개 이상의 저장소에 위임할 수 있다.

구현? -> 객체 관계 매핑(ORM) - 하이버네이트(Hibernate)가 가장 유명한 ORM 중 하나

- 일부 작업을 자동화할 수 있지만 데이터베이스 쿼리 코드 결과물의 최적화가 완벽하지 못할 때도 있어 상황이 더 복잡해지기도 한다.

## 함수형 프로그래밍

- 메서드를 수학 함수처럼 취급하는 컴퓨터 프로그래밍 형식이다.
- 함수형 프로그래밍에서는 가변 상태와 데이터 변경을 피한다.

자바 8에서 함수형 프로그래밍 구현에 도움을 주는 몇 가지 기능이 추가되었다.

- 람다 표현식
- 스트림 API, 컬렉터  API(Collectors API)
- Optional 클래스 등

자바 8이전에는 라이브러리 개발자가 활용할 수 있는 추상화 수준에 한계가 있었다. - 큰 데이터 컬렉션에서는 효과적으로 병렬 연산을 수행할 수 없었다.

자바 8부터

- 복잡한 컬렉션 처리 알고리즘을 구현할 수 있다.
- 메서드 호출 방식을 살짝 바꿔 멀티코어 CPU를 효율적으로 활용할 수 있다.
- 스레드 안전(thread safety)을 갖춘 복잡한 코드를 구현할 수 있다. -> 시간과 비용 절약

함수형 프로그래밍에서는 **동작 추상화**에 초점을 둔다.

새로운 추상화(동작 추상화)는

- 최적의 성능을 추구하는 코드를 작성하려는 것보다, 동작이 어떤 방식으로 수행했는지 보다 비즈니스 로직의 의도를 표현하기 위해 더 많은 시간을 투자해 읽기 쉬운 코드 구현을 목표로 한다.
- -> 읽기 쉬운 코드는 읽기 어려운 코드보다 유지보수가 쉽고, 더 안정적이며 오류가 적게 발생한다.

### 람다 표현식

익명 함수를 람다 표현식으로 줄여서 정의한다.

쓸모없는 코드가 있다는 문제, 프로그래머의 의도를 이해하기가 어려운 코드 문제 -> 객체를 전달하는 것이 아니라 어떤 동작을 전달하는 **람다 표현식**으로 해결

- 인터페이스를 구현하는 객체를 전달하는 대신, 코드 블록(이름이 없는 함수)를 전달한다.

### 메서드 레퍼런스

```java
// 람다 표현식 - 제공된 파라미터의 메서드를 호출한다.
twoot -> twoot.getContet();

// 메서드 레퍼런스라는 단축 구문으로 기존 메서드를 표현
Twoot::getContent
```

- **클래스 이름::메서드 이름**
- 메서드이지만, 실제로 메서드를 호출하지는 않으므로 괄호를 사용하지 않는다.
- 람다 표현식을 메서드 레퍼런스로 대체할 수 있다. 람다 표현식 대신 메서드 레퍼런스를 사용할 수 있다.

단축 구문으로 생성자 호출

```java
// 람다
(user, twootr) -> new SenderEndPoint(user, twootr);

// 메서드 레퍼런스
SenderEndPoint::new
```

- 메서드 레퍼런스로 코드를 단축할 수 있을 뿐만 아니라 읽기도 쉬워졌다.

- 올바른 함수형 인터페이스를 갖춘다면 메서드 레퍼런스는 자동으로 여러 파라미터를 처리한다.

- 메서드 레퍼런스 덕분에 함수가 명시적으로 일급의 개념(concept)으로 취급된다. 

  > 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 
  >
  > 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라고 한다.

- 마치 값처럼 동작을 전달하고 처리할 수 있어 두 개 이상의 함수를 조합할 수도 있다.

### 실행 어라운드

함수형 디자인 패턴에서 자주 사용된다.

항상 비슷한 작업을 수행하는 초기화, 정리 코드에서 실행하는 비즈니스 로직에 따라 이를 파라미터화한다.

- 초기화, 정리 로직은 여러 곳에서 사용되므로 코드가 중복될 수 있다. -> 초기화, 정리 코드를 바꿔야 한다면, 응용프로그램의 여러 장소에서 코드를 바꿔야 한다.
- 중복된 코드가 존재하므로 코드의 일관성이 사라지면서 응용프로그램에 잠재 버그가 생길 수 있다.

실행 어라운드 패턴에서는

- 초기화, 정리 코드에서 공통 메서드를 추출해 문제를 해결한다. 이 메서드에서는 같은 전체 패턴의 유스 케이스에 따라 다른 동작을 수행하도록 파라미터를 받는다.
- 보통 람다 표현식의 코드 블록으로 필요한 기능을 구현할 수 있도록 인터페이스를 파라미터로 정의한다.

### 스트림

스트림 덕분에 루프를 이용하지 않고 높은 수준으로 컬렉션 처리 코드를 추상화할 수 있다. **병렬 처리**를 할 수 있다.

- map()
  - 어떤 형식의 값을 포함하는 스트림을 다른 형식의 값의 스트림으로 변환한다.
- forEach()
  - 스트림의 값에 부작용을 일으키는 작업을 수행할 때 활용한다.
  - 스트림의 모든 요소를 인수로 받아 작업을 수행하는 Consumer 콜백을 한 개의 인수로 받는다.
- filter()
  - 어떤 데이터를 반복하면서 각 요소에 if문을 적용하는 상황에 이용한다.
  - 스트림의 특정 요소만 보존하고 다른 요소는 버린다.
- reduce()
  - 전체 리스트를 한 개의 값으로 줄이는 상황에 이용한다. 
  - 예) 다양한 트랜잭션에서 모든 값의 합계를 찾는 작업

### Optional

Optional은 null을 대신하도록 자바 8에서 추가된 코어 자바 라이브러리 데이터 형식이다.

기존 null 방식의 문제점 

- null을 사용하면 NullPointerException이 발생하는 문제가 있다.
- -> null인 변수를 참조하면 프로그램이 즉시 종료된다.

Optional은 두 가지 기능을 제공한다.

- 버그를 피하기 위해 변수의 값이 있는지 개발자가 확인하도록 장려한다.
- 클래스의 API에서 값이 없을 수 있다는 사실을 Optional 자체로 문서화한다.

사용 방법

- of()
  - Optional 인스턴스를 만든다.
- get()
  - 안에 있는 값을 꺼낼 수 있다.
- empty()
  - 값을 갖지 않음을 나타낸다.
- ofNullable()
  - null이 될 수 있는 값을 만든다.
- isPresent()
  - Optional이 값을 포함하는지 확인한다.
- orElse()
  - Optional이 비었을 때 대쳇값을 제공한다.
- orElseGet()
  - 대쳇값 계산에 시간이 많이 걸릴 때 Supplier 함수를 전달하여 실행한다.

스트림 API에서 제공하는 것과 비슷한 기능 수행 -> 오직 1개 또는 0개 요소만 포함할 수 있다.

- filter()
  - 조건을 만족하면 Optional의 요소를 유지하고, Predicate(참이나 거짓을 반환하는 함수) 결과가 거짓이거나 빈 Optional이면 그대로 빈 Optional을 반환한다.
- map()
  - Optional 안의 값을 변환하는데, 값이 없으면 함수를 아예 적용하지 않는다.
- forEach()
  - ifPresent()를 함께 사용하며 값이 있을 때만 Consumer 콜백을 적용한다.



## 사용자 인터페이스

자바스크립트 프론트엔드와 서버 간의 모든 통신은 JSON 표준으로 이루어진다. 자바스크립트 UI로 쉽게 직렬화, 비직렬화 할 수 있기 때문이다.

자바 코드로 JSON 인코딩, 디코딩 -> Jackson 라이브러리 사용

이벤트 주도 방식보다 요청 응답 방식의 응용프로그램에서 JSON을 주로 사용한다.



## 의존 관계 역전과 의존관계 주입

결합을 제거하는 패턴 -> 비즈니스 로직과 세부 구현의 결합 제거

- 포트와 어댑터 패턴
- 저장소 패턴

**의존관계 역전**은 이들 패턴을 아우르는 원칙이다.

- 높은 수준의 모듈은 낮은 수준의 모듈에 의존하지 않아야 한다. 두 모듈 모두 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존하지 않아야 한다. 세부 사항은 추상화에 의존해야 한다.

한 개의 큰 문제를 여러 작은 문제로 쪼개고 이 작은 문제를 각 ㄱ모듈이 해결하도록 구현하면, 주요 문제(높은 수준 모듈)가 작은 문제들(낮은 수준 모듈)을 의존하게 된다.

=> 추상화로 이 문제를 해결한다. - 세부 구현이 아니라 인터페이스를 바라보고 프로그램을 구현

**의존관계 주입(DI)**

인터페이스를 정의하고 구현을 분리하는 것으로는 부족하다. 추상화, 결합 제거를 유지할 수 있도록 올바른 구현을 제공하는 방법이 필요하다.

- 디자인 패턴 중 **추상 팩토리 패턴**으로 의존성을 인스턴스화하는 방법이 있다. -> 인터페이스와 구현을 분리하며 원하는 시점에 필요한 구현을 연결한다.
- 문제
  - 아주 큰 덩어리의 공유된 가변 상태를 갖게 된다.
  - 응용프로그램과 저장소의 생명주기가 묶여버린다.
  - 기존의 인스턴스를 재사용할 수 없으며 항상 새로운 저장소를 인스턴스화해야 한다. (팩토리 메서드는 재사용 기능을 제공하지 않기 때문)

의존관계 주입을 이용하면 문제를 해결할 수 있다.

- 명시적으로 디펜던시나 팩토리를 만들 필요가 없다.
- 필요한 인수를 제공하면 디펜던시에 필요한 책임을 담당하는 객체를 알아서 인스턴스화한다.
- 객체를 쉽게 테스트할 수 있고 객체 생성을 외부로 위임한다.
- 어떤 구현과 연결할 지 쉽게 제어할 수 있다.



## 패키지와 빌드 시스템

자바에서는 코드베이스를 여러 패키지로 쪼갤 수 있다.

- 큰 프로젝트를 다양한 패키지로 쪼개면 개발자가 쉽게 기능을 찾을 수 있도록 코드를 조직할 수 있다.

클래스의 결합도, 응집도 원칙은 패키지에도 적용된다.

패키지는 정보 은닉 기능도 제공한다.

- 패키지로 클래스와 메서드 접근 범위를 제한해 외부 패키지에서 내부 패키지의 세부 구현에 접근하지 못하도록 막으므로 결합도를 낮춘다.

패키지당 한 개의 어댑터를 만드는 방식은 모듈에서 사용한 육각형 아키텍처 패턴과도 잘 어울린다. (모든 응용프로그램이 적용하는건 아니다.)

보통 두 가지 패키지 구조를 많이 사용한다.

- 패키지를 계층(layer)으로 구분
  - view 패키지 / controller 패키지
  - 구조를 잘 결정하지 않으면 결합도와 응집도에 문제가 생긴다.
- 기능으로 코드를 그룹화
  - 장바구니 기능 cart / 제품 목록 product / 카드 결제 관련 payment
  - 응집도를 높일 수 있다.

