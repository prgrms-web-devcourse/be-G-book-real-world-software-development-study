# 4장

4장에서는 무엇을 배우는가?

- 어떻게 클래스를 상속하거나 인터페이스를 구현하는지에 대한 `상속관계`
- `리스코프 치환 원칙`
- 언제 상속을 사용해야 하는지와 관련해서는 `상속보다 조합` 원칙
- 유지보수가 쉽고 좋은 테스트를 만드는 방법을 활용해 자동화된 코드 구현 지식을 확장

## 문서 관리 시스템 요구 사항

기존 환자 정보 파일을 읽어 색인을 추가하고 검색할 수 있는 형태의 정보로 변환해야 하는 `문서 관리 시스템`을 만든다.

세 가지 형식의 문서를 다룬다.

```
1. 리포트 : 환자 수술과 관련된 상담 내용을 기록한 본문
2. 우편물 : 특정 주소로 발송되는 텍스트 문서
3. 이미지 : 치아와 잇몸 엑스레이 사진을 저장한다. 용량이 크다.
+) 차츰 다른 종류의 문서도 추가한다.
```



## 설계 작업

### 임포터 구현

다양한 종류의 문서를 임포트하는 것이 문서 관리 시스템의 핵심 기능.

- Switch문으로 다양한 종류를 분기 처리한다면?
  - 확장성 부족
    - 다른 종류의 파일을 추가할 때마다 switch문에 추가 구현해야함.
    - 이는 메서드 다루기가 어렵고 읽기 어려워짐.
- 해결방법은?
  - 다양한 문서를 임포트하는 클래스로 분리
    - 임포트 동작을 따로 처리하므로 찾기 쉽고, 이해하기 쉬운 코드를 만들 수 있음.
  - 다양한 종류의 문서 임포트를 지원하도록 `Importer` 인터페이스를 정의
- 또 다른 문제 발생❗️임포트하려는 파일은 어떻게 표현해야할까? (`File` 클래스로? `String`으로?)
  - **`강한 형식(strong typed)의 원칙`**을 적용하자.
    - `String` 대신 파일을 가리키는 **전용 형식**을 이용하므로 오류가 발생할 범위를 줄인다.
    - **강한 형식**은 프로그래밍 언어와 관련한 것도 있지만, **소프트웨어를 구현하는 실용적인 의미**로 여기서 쓰인다.
    - 이를 이용하면 **데이터의 사용 방법을 규제**할 수 있다.
      - 불변 클래스로 구현하여 오류가 발생한 원인을 좁힐 수 있으며 안전하게 클래스로 색인(index)를 만들거나 정보를 캐시할 수 있다.
    - 이 책은 클래스로 모델을 만들어 <u>강한 형식의 원칙</u>을 따르도록 권장한다.
  - 그래서 우리는 `java.io.File` 객체를 사용해 임포트하는 파일을 가리킨다.

### Document 클래스

문서의 종류에 따라 포함하는 속성이 달라지는데 이를 위해 Document 클래스를 정의한다.

- Document 정의 방식

  1. `Map<String, String>` 으로 속성 이름을 값과 매핑하는 방법.

     - 한 문서를 모델링하려고 새 도메인 클래스를 소개하는 것은 간단한 것이 아니라, **응용프로그램의 유지보수성과 가독성을 고려**해야하는 일이기 때문에 비추!

     > **유비쿼터스 언어**
     >
     > 훌륭한 소프트웨어 개발팀은 <u>유비쿼터스 언어</u>로 자신의 소프트웨어를 작성한다. 고객과 대화할 때 사용하는 용어를 응용프로그램의 코드와 같은 의미로 사용하면 유지보수가 쉬워진다. 또한 코드의 어떤 부분을 바꿔야 하는지 쉽게 알 수 있으며 이를 **`발견성`** 이라고 한다.
     >
     > 유비쿼터스 언어는 도메인 주도 설계(Domain-Driven Design) 에서 처음 등장하였으며 개발자와 사용자 모두가 사용할 수 있도록 설계, 공유된 공통 언어를 말한다.

  2. `HashMap<String, String>` 을 상속받도록 설계한다면?

     - 필요한 기능은 추가하면서 동시에 불필요한 기능은 제한해야하는데 Document 클래스가 HashMap을 상속하면서 응용프로그램이 Document 클래스를 바꿀 수 있도록 결정한다면 이전에 불변성으로 얻을 수 있는 모든 이득이 단번에 사라진다.

- 요약하자면 도메인 클래스를 이용하면 

  1. 개념에 이름을 붙이고 -> 유비쿼터스 언어 (쉬운 유지보수)
  2. 수행할 수 있는 동작과 값을 제한 -> 발견성을 개선하고, 버그 발생 범위를 줄임

- 추가적인 Tip

  - Document 생성자를 `public`으로 지정하지 않고 `default`로 접근제한지정자를 설정하면, <u>오직 문서 관리 시스템에서만</u> Document를 만들 수 있어야 하므로 패키지 영역으로 생성자를 제공하고, 문서 관리 시스템이 위치한 패키지에만 접근 권한을 준다.

### Document 속성 및 계층

1. Document 클래스는 속성에 String을 사용하였는데 장단점이 있다.

   - 장점 : 텍스트로 속성을 검색할 수 있으며, Importer의 종류와 관계없이 모든 속성이 아주 일반적인 형식으로 갖도록 만들려는 의도가 있음.
   - 단점(?) : 응용프로그램에서 String으로 정보를 전달하는 것은 보통 좋지 않은 방법으로 알려져 있음.

   이런식으로 String으로 구현한 형식을 강한 형식에 빗대어 **문자화 형식(Stringly Typed)**이라 부른다.

   - 이런 형식을 좋지 못한 이유
     - 우선 속성값을 복잡하게 사용할 때는 다양한 속성 형식으로 파싱하는 것이 좋다. 만약 문서에 높이와 너비를 가진 이미지를 검색할 때 강한 형식(정숫값)을 가진 속성이 훨씬 도움되기 때문이다.

2. Importer의 구성 계층을 그대로 Document 클래스 계층에 사용할 수 있다.
   - 예를 들어 ReporterImporter 는 Report 클래스 (Report는 Document 클래스 상속)의 인스턴스를 임포트 한다.
     - 이렇게 하면 상속으로 기본적인 무결성 검사(sanity check)를 대신할 수 있다.
     - 즉 Report는 Document다라고 말할 수 있다.
   - 하지만, 이 정도로 직접적인 표현을 사용하지 않는다.
     - 왜? OOP에서는 동작과 데이터의 관점으로 클래스를 설계하기 때문임.
3. `KISS` 원칙을 적용하자. 
   - 문서의 각 서브클래스가 전용 필드를 갖지 않도록 모든 알려진 속성을 범용으로 설계한다.
   - 클래스 계층으로 인한 이득이 없다면 계층을 추가할 필요가 없다.
     - Keep In Simple Stupid 처럼 되도록 단순하게 일을 처리하려는 노력이 필요하다.
     - 좋은 의도를 가진 확장성, 반드시 필요한 기능보다는 있으면 좋은 기능의 코드를 추가하다 보면 <u>결국 설계가 얼룩지고 복잡해진다</u>.

### Importer 구현과 등록

다양한 형식의 파일을 지원하도록 Importer 인터페이스를 구현해보자.

```java
// com.iteratrlearning.shu_book.chapter_04.Attributes
public final class Attributes
{
    public static final String PATH = "path";
    public static final String PATIENT = "patient";
    public static final String ADDRESS = "address";
    public static final String BODY = "body";
    public static final String WIDTH = "width";
    public static final String HEIGHT = "height";
    public static final String TYPE = "type";
    public static final String AMOUNT = "amount";
}

// -----
// com.iteratrlearning.shu_book.chapter_04.Attributes.ImageImporter
import static com.iteratrlearning.shu_book.chapter_04.Attributes.*;

class ImageImporter implements Importer {
    @Override
    public Document importFile(final File file) throws IOException {
        final Map<String, String> attributes = new HashMap<>();
        attributes.put(PATH, file.getPath());

        final BufferedImage image = ImageIO.read(file);
        attributes.put(WIDTH, String.valueOf(image.getWidth()));
        attributes.put(HEIGHT, String.valueOf(image.getHeight()));
        attributes.put(TYPE, "IMAGE");

        return new Document(attributes);
    }
}
```

- 속성명을 따로 Attributes 클래스에 정의하면 문자열을 잘못 사용하는 실수를 방지할 수 있다.

3. 책에서 속성값에서 문자열을 검색하는 요구사항을 구현할 수 있다는데 신기하다.

- Query문 예시 : `patient:Joe,body:Diet Coke` 

```java
// com.iteratrlearning.shu_book.chapter_04.Query
class Query implements Predicate<Document> {
    private final Map<String, String> clauses;

    private Query(final Map<String, String> clauses) {
        this.clauses = clauses;
    }

    static Query parse(final String query) {
        return new Query(
          		Arrays.stream(query.split(","))
              	.map(str -> str.split(":"))
	              .collect(toMap(x -> x[0], x -> x[1])) // Map으로 만들어 준다.
        );
    }
  	// ...
}

// ======
// com.iteratrlearning.shu_book.chapter_04.DocumentManagementSystem
public class DocumentManagementSystem {
    private final List<Document> documents = new ArrayList<>();
  	// ...
  	
    public List<Document> search(final String query) {
        return documents.stream()
                        .filter(Query.parse(query)) // 위의 Query Class
                        .collect(Collectors.toList());
    }
}
```

## 리스코프 치환 원칙(LSP)

**리스코프 치환 원칙**은 클래스의 상속과 인터페이스 구현을 올바르게 사용하도록 도와준다. 아주 간단하다.

- 몇 가지 관련 용어를 일단 알아보자.
  - **형식(type)** : 클래스나 인터페이스를 떠올리자
  - **하위형식(subtype)** : 두 형식이 부모와 자식 관계를 이루었음을 의미 -> 클래스 상속이나 인터페이스 구현이 이에 해당

LSP를 네 개의 부분으로 쪼갤 수 있다.

### 하위형식에서 선행조건을 더할 수 없음

부모가 지정한 것보다 더 많은 선행조건을 요구할 수 없음을 의미한다.

- **선행조건**은 어떤 코드가 동작하는 조건을 결정하는 것.
- 예를 들어 부모가 문서의 크기를 제한하지 않았다면, 자식에서 문서의 크기가 100KB보다 작아야 한다고 요구할 수 없다.
  -  <!-- 이게 대체 머선 말이고? 자식에서 더 세세한 Validation을 걸지 말라는 뜻인가? -->

### 하위형식에서 후행조건을 약화시킬 수 없음

부모가 부작용을 포함하거나 어떤 값을 반환한다면 자식도 그래야 한다.

- **후행조건**은 어떤 코드를 실행한 다음에 만족해야 하는 규칙이다.

### 슈퍼형식의 불변자는 하위형식에서 보존됨

상속관계의 부모와 자식 클래스가 있을 때, 부모 클래스에서 유지되는 모든 불변자는 자식클래스에서도 유지되어야 한다.

- 불변자란 <u>항상 변하지 않는 어떤 것</u>을 가리킨다.
- <!--이런게 있나? public static final int IMMUTABLE_INT = 1; 가 부모에서 선언 되었다면 자식에서도 유지되어야 하는게 맞지 않나? -->

### 히스토리 규칙

기본적으로 자식 클래스는 부모가 허용하지 않은 상태 변화를 허용하지 않아야 한다.

- 만약 부모의 불변 필드가 자식에서 불변이 아니라면 호출자의 예상을 뒤엎기 때문.

## 문서 관리 시스템 대안

### 임포터를 인터페이스가 아닌 클래스로 만들기

* 인터페이스와 클래스는 서로 다른 기능을 제공
  * 인터페이스: 여러 개를 한 번에 구현할 수 있음
  * 클래스: 일반 인스턴스 필드와 메서드를 가짐.

쉽게 망가질 수 있는 상속 기반의 클래스를 피해야 한다. -> **인터페이스 사용**이 대부분의 상황에서 적절.

문제를 해결하려는 도메인에 상태와 많은 동작이 관련되어 있어서 강력한 **`is a 관계`**를 모델링해야 하는 상황이라면 **클래스 기반의 상속**이 인터페이스 사용보다 더 적절하다.

### 영역, 캡슐화 선택하기

- 같은 패키지 안의 클래스만 패키지 영역의 클래스를 보거나 접근할 수 있으며 패키지 밖에서는 보거나 접근할 수 있다. 이는 일종의 은폐 장치.
- 클래스가 외부로 노출되지 않도록 패키지 영역을 적극적으로 적용하면 내부 설계를 쉽게 바꿀 수 있다.

## 기존 코드 확장과 재사용

코드를 재사용하려면 코드를 어떤 클래스에 구현해야하는데 세 가지 방법 중 선택할 수 있다.

### 1. 유틸클래스 사용

가장 간단한 방법이지만 결국 여러 정적 메서드를 포함하면서 갓 클래스의 모양을 갖춰나가므로 안좋음!

### 2. 상속 사용

공통 기능을 부모 클래스에 구현하고 서브클래스에서는 공통 기능을 재사용한다면?

- 실제 관계를 제대로 반영하지 않은 상속은 쉽게 깨질 수 있다는 점이 문제이다.
- 시간이 흐르고 응용프로그램이 바뀔 때, 응용프로그램을 그에 맞게 바꾸는 것보다는 **변화를 추상화**하는 것이 더 좋다.

일반적으로 상속 관계로 코드를 재사용하는 것은 좋은 방법이 아니다.

### 3. 도메인 클래스 사용

도메인 클래스로 <u>기본 개념을 모델링</u>한 다음 <u>기본 개념이 제공하는 메서드를 호출</u>하는 방법은?

- 기본 개념이란?
  - 새롭거나 창의적이지 않다는 점이 핵심이다. 클래스 이름이 매우 단순 명료하게 하여 어디에 추가할지 쉽게 알 수 있음 이 뽀인뜨!
- 도메인 클래스 구현
  - 도메인 클래스를 이용하면 유연성을 개선할 수 있다.
  - 상속 같이 쉽게 깨질 수 있는 계층을 만들지 않으면서도 코드를 재사용할 수 있다.
- 때로는 클래스를 만드는 것보다 코드가 조금 중복되도록 두는 것이 좋을 때도 있다는데?
  - 올바른 추상화를 달성할 수 있기 때문. 그래서 **<u>중복된 코드를 제거하는 것이 충분히 좋은 사실이라고 결정할 수 있을 만큼 정보가 충분해진 다음</u>**에 중복을 제거해도 늦지 않습니다.

## 테스트 위생

테스트를 구현하면 

- 소프트웨어 유지보수에 큰 도움이 된다. 
- 자동화된 테스트는 퇴행(regression)이 발생하는 범위를 줄이며 어떤 동작이 문제를 일으켰는지 이해할 수 있도록 도화준다.
- 자동화된 테스트가 있으면 자신 있게 코드를 리팩터링할 수 있다.

하지만 이를 위해

- 코드를 많이 구현해보고 유지보수 해야 하기 때문에 작업량이 많아진다.
- 또한 자동화 테스트의 첫 단추를 끼우는 일이 쉽지 않다.

테스트 유지보수 문제를 해결하려면 **`테스트 위생`**을 지켜야한다.

- 테스트 위생이란 테스트 대상 코드베이스뿐 아니라 테스트 코드도 깔끔하게 유지하며 유지보수하고 개선해야 함을 의미.

### 1. 테스트 이름 짓기

테스트 이름을 지을 때 고려 사항

- 가독성
- 유지보수성
- **실행할 수 있는 문서**의 역할

동작과 코드가 가급적 일치해야 나중에 다른 개발자가 코드를 쉽게 이해할 수 있다.

나쁜 이름 예시 (안티 패턴)

- test1
- 개념이나 명사로 테사트의 이름을 결정 : file, document

**<u>좋은 이름 예시</u>**

- **도메인 용어 사용**
  - 문제를 지칭할 때 사용하는 용어를 테스트 이름에 사용한다.
- **자연어 사용**
  - 모든 테스트 이름은 일반 문장처럼 쉽게 읽을 수 있어야한다. 테스트 이름은 항상 어떤 동작을 쉽게 이해할 수 있도록 묘사해야한다.
- **서술적**
  - 코드는 한 번 구현하면 여러 번 읽게 된다. 따라서 처음부터 시간을 들여 서술적인 좋은 이름을 붙이자.

### 2. 구현이 아닌 동작

클래스, 컴포넌트, 시스템 테스트를 구현할 때는 대상의 공개 동작(public behavior)만 테스트한다.

테스트는 객체의 <u>내부 상태나 설계는 고려하지 않고</u> **오직 공개 API 메서드만 이용해** 테스트를 수행해야 한다.

쉽게 테스트하기 위해 게터나 세터로 상태를 노출하면, **장기적 관점**에서 응용프로그램을 유지보수하기 어렵고 **코드베이스를 바꾸면 테스트에도 영향**을 미치기 때문에 좀 더 쉽고 효과적으로 테스트할 수 있도록 새 클래스를 만드는 **리팩터링이 필요하다**는 신호를 알 수 있다.

### 3. 중복 배제

이전 중복 코드를 제거하는 방법을 알아봣었는데 **똑같은 원칙이 테스트 코드**에도 적용된다. 

### 4. 좋은 진단

테스트가 실패하지 않으면 

- 테스트가 잘 동작하는지 알 수 없다.
- 그래서 실패에 `최적화`된 테스트를 구현하는 것이 좋은 이유이다.
  - 최적화란? 테스트를 더 빨리 수행하는 것이 아닌, <u>테스트가 실패한 이유를 쉽게 이해할 수 있도록</u> 만들어야 한다는 의미.
  - 이때 **`좋은 진단`**(good diagnostics)을 활용한다.

진단이란

- 테스트가 실패했을 때 출력하는 메시지와 정보를 의미한다.
- 실패한 이유를 설명하는 메시지가 명확해야 쉽게 디버깅할 수 있다.

좋은 진단 정보를 어떤 형식으로 코드에 추가할 수 있을까?

- `assertTrue()` 나 `assertEquals()` 로는 실패 사항들에 대한 결정적 단서를 얻기 어렵다.
- **`매처`**(Matchers)로 컬렉션 크기를 확인하는 것이 가장 좋은 방법이다.
- 왜냐하면 가장 자세한 설명 진단이 제공되기 때문.

```java
// not good
assertTrue(documents.size() == 0);
assertEquals(0, document.size());

// good
assertThat(documents, hasSize(0));
```

- 인수로 Matcher를 받는데 **<u>Matcher는 값이 어떤 속성과 일치하는지와 관련 진단을 캡슐화 한다.</u>**
  - **햄크레스트**(hamcrest)라는 유명한 자바 라이브러리에서 제공하는 기능을 이용해 깔끔하게 테스트코드를 구현한다.

### 5. 오류 상황 테스트

우리의 코드가 항상 잘 되기만을 꿈꾸지 말라... 실제 상황에선 다양한 문제들이 발생할 수 있다.

- 존재하지 않는 파일이나 읽을 수 없는 파일을 임포트하려 시도하거나 텍스트를 추출하고 읽는 방법을 알 수 없는 파일을 임포트 할 수도 있겠다.

이러한 예외 상황을 테스트 하기위해 

- 각각 문제가 발생하는 파일을 임포트한다.
- '이 테스트는 이런 종류의 예외를 던질 거에요' 의미를 전달하는 @Test 애너테이션을 이용한다.

```java
// 존재하지 않는 파일읽기
@Test(expected = FileNotFoundException.class) // 1. @Test 애너테이션의 'expected=' 속성을 사용해 원하는 어서션을 추가
public void shouldNotImportMissingFile() throws Exception {
  system.importFile("gobbledygook.txt");
}

// 읽는 방법을 알 수 없는 파일을 임포트 하기
@Test(expected = UnknownFileTypeException.class)
public void shouldNotImportMissingFile() throws Exception {
  system.importFile(RESOURCES + "unknown.txt");
}
```

### 6. 상수

테스트에서는 프로그램을 어떻게 사용해야 하는지 예를 포함하므로 많은 상수를 사용한다.

- 상수에도 테스트에 활용되는 용도에 따라 **적절한 이름**을 붙이는게 좋다.
