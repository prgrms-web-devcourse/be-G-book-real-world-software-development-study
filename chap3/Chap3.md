# 입출금 내역 분석기 확장판

## 개방/폐쇄 원칙

특정 금액 이상의 모든 입출금 내역을 검색하는 메서드를 어디에 정의해야 할까?

1. 해당 메서드를 포함하는 새로운 클래스를 따로 만든다. -> 이미 BankTransactionProcessor 클래스를 선언했다.

- 메서드를 추가하려고 클래스를 새로 만들어도 크게 좋은 점이 없다. 새로 클래스를 추가한 탓에 여러 이름이 생기면서 다양한 동작 간의 관계를 이해하기가 어려워지고 전체 프로젝트가 복잡해진다.

2. 일종의 처리 기능을 담당하므로 기존 BankTransactionProcessor 클래스 안에 정의한다. -> 나중에 관련 메서드를 조금 더 쉽게 찾을 수 있다. (예제3-1, 예제3-2)

- 코드 중복 문제가 발생한다.
- 중복 코드는 소프트웨어를 불안정하게 만든다. 특히, 요구 사항이 자주 바뀔수록 영향이 커진다.

3. 특정 월 또는 특정 금액으로 입출금 내역을 검색하는 메서드를 만든다. (예제3-3)

- 거래 내역의 여러 속성을 조합할수록 코드가 점점 복잡해진다.
- 반복 로직과 비즈니스 로직이 결합되어 분리하기가 어려워진다.
- 코드를 반복한다.

=> 개방/폐쇄 원칙을 적용해서 문제를 해결한다.

개방/폐쇄 원칙을 적용하면

- 코드를 직접 바꾸지 않고 해당 메서드나 클래스의 동작을 바꿀 수 있다.
- 메서드의 코드를 복사하거나 새 파라미터를 추가하는 등 코드를 바꾸지 않고도 동작을 확장할 수 있다.
- 비즈니스 로직을 담당하는 BankTransactionFilter **인터페이스를 만들어 문제를 해결**한다. (예제3-4)

새로운 인터페이스를 이용해 반복 로직과 비즈니스 로직의 결합을 제거하는 중요한 리팩터링 과정-BankTransactionFilter 인터페이스를 이용하도록 findTransactions() 메서드를 리팩터링 (예제3-5)-을 거치면

- 기존에 이미 구현하고 검증한 코드를 바꾸는 일을 최소화할 수 있다.
- 새로운 버그가 발생할 만한 대상을 줄일 수 있다.

### 함수형 인터페이스 인스턴스 만들기

새로운 요구 사항에 맞는 필터를 구현한 후, findTransactions() 메서드의 인수로 필터의 인스턴스를 전달한다. (예제3-6, 예제3-7)

### 람다 표현식

새로운 요구 사항이 있을 때마다 별도의 클래스를 만들어야 한다. 큰 위미가 없는 코드를 반복해서 만드는 귀찮은 작업이다.

=> 람다 표현식을 이용해 이름 없이 인터페이스 구현 객체를 코드 블록 형태로 전달한다. (예제3-8)

### 개방/폐쇄 원칙 사용의 장점

- 기존 코드를 바꾸지 않으므로 기존 코드가 잘못될 가능성이 줄어든다.
- 코드가 중복되지 않으므로 기존 코드의 재사용성이 높아진다.
- 결합도가 낮아지므로 코드 유지보수성이 좋아진다



## 인터페이스 문제

리팩터링 후 BankTransactionProcessor 클래스 안의 다른 메서드는 어떻게 해야 할까??

- 인터페이스로 옮겨야 할까?
- 다른 클래스로 옮기는게 좋을까?

=> 한 인터페이스에 모든 기능을 추가하는 **갓 인터페이스 만드는 일은 피해야**한다.

### 갓 인터페이스

여러 입출금 내역 분석기 구현에서 결합을 제거하도록 입출금 내역 분석기가 구현해야 할 모든 기능 포함한 인터페이스를 정의한다. (예제3-9)

- 모든 헬퍼 연산이 명시적인 API 정의에 포함되면서 **인터페이스가 복잡**해진다.
- 갓 클래스와 비슷한 인터페이스가 만들어진다.

-> 두 가지 형식의 결합이 발생한다.

- 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야 한다.
  - 인터페이스를 바꾸면 이를 구현한 코드도 바뀐 내용을 지원하도록 갱신되어야 한다.
  - 더 많은 연산을 추가할수록 더 자주 코드가 바뀌며, 문제가 발생할 수 있는 범위도 넓어진다.
- 인터페이스가 도메인 객체의 특정 접근자에 종속되는 문제가 생겼다.
  - 도메인 객체의 세부 내용이 바뀌면 인터페이스도 바뀌어야 하며 결과적으로 구현 코드도 바뀌어야 한다.

=> **작은 인터페이스**를 권장한다. 도메인 객체의 다양한 내부 연산으로의 디펜던시를 최소화할 수 있다.

### 지나친 세밀함

각 동작을 별도의 인터페이스로 정의한다. (예제3-10) -> BankTransactionProcessor 클래스는 모든 인터페이스를 구현해야 한다.

지나치게 인터페이스가 세밀하면

- 코드 유지보수에 방해가 된다.
- 안티 응집도 문제가 발생한다. 기능이 여러 인터페이스로 분산되므로 필요한 기능을 찾기가 어렵다.
- 복잡도가 높아지며, 새로운 인터페이스가 계속해서 프로젝트에 추가된다.



## 명시적 API vs 암묵적 API

개방/폐쇄 원칙을 적용하면 연산에 유연성을 추가하고 가장 공통적인 상황을 클래스로 정의할 수 있다.

### 명시적 API

- 장점
  - 자체적으로 어떤 동작을 수행하는지 잘 설명되어 있다.
  - 사용하기 쉽다.
  - API의 가독성이 좋고 쉽게 이해할 수 있다.

- 단점
  - 메서드의 용도가 특정 상황에 국한되어 각 상황에 맞는 새로운 메서드를 많이 만들어야 하는 상황이 벌어진다.

### 암묵적 API

- 장점
  - 필요한 모든 상황을 단순한 API로 처리할 수 있다.
- 단점
  - 처음 사용하기가 어렵고, 문서화를 잘해놓아야 한다.

=> 필요한 질문의 종류에 따라 합리적인 선택이 필요하다.



### 도메인 클래스 vs 원싯값

원싯값으로는 다양한 결과를 반환할 수 없어 유연성이 떨어진다.

=> **도메인 클래스**를 만들어서 이 문제를 해결한다. 

- 새 클래스에 필요한 필드와 결과를 언제든 추가할 수 있다.
- 도메인의 다양한 개념간의 결합을 줄일 수 있다.
- 요구 사항이 바뀔 때 연쇄적으로 코드가 바뀌는 일을 최소화할 수 있다.



## 다양한 형식으로 내보내기

### 도메인 객체 소개

다양한 형식의 장단점

- 숫자
  - 가장 간단하게 프로그램을 구현할 수 있지만 요구 사항이 바뀔 때 유연하게 대처할 수 없다.
- 컬렉션
  - Iterable을 반환하면 상황에 맞춰서 처리하기 때문에 유연성을 높일 수 있다.
  - 오직 컬렉션만 반환해야 한다는 제약이 따른다.
- 특별한 도메인 객체
  - 내보내려는 요약 정보를 대표하는 새로운 개념을 만들 수 있다.
  - 도메인 객체를 이용하면 결합을 깰 수 있다.
  - 새로운 요구사항이 생겨서 추가 정보를 내보내야 한다면 기존 코드를 바꿀 필요 없이 새로운 클래스의 일부로 이를 구현할 수 있다.
- 더 복잡한 도메인 객체
  - 조금 더 일반적이며 다양한 결과를 저장하는 필드를 포함하는 개념을 만들 수 있다.
  - 사용자의 요구사항, 더 복잡한 정보를 내보내야 하는지 여부에 따라 사용할 도메인 객체가 달라진다.
  - 객체를 생산하는 부분과 이를 소비하는 부분이 서로 결합하지 않는다는 큰 장점이 있다.

### 적절하게 인터페이스를 정의하고 구현하기

인터페이스를 정의해 다양한 내보내기 구현 코드가 다른 코드와 결합하지 않도록 방지한다. (개방/폐쇄 원칙)

JSON으로 내보내든, XML로 내보내든 같은 인터페이스를 구현하면 되므로 다양한 내보내기 기능을 편리하게 구현할 수 있다.

```java
// 인터페이스의 나쁜 예
public interface Exporter {
  void export(SummaryStatistics summaryStatistics);
}
```

인터페이스를 위와 같이 정의할 때 문제 발생

- void 반환 형식은 아무 도움이 되지 않고, 기능을 파악하기도 어렵다. 인터페이스로부터 얻을 수 있는 정보가 아무것도 없다.
- void를 반환하면 Assertion으로 결과를 테스트하기도 매우 어렵다.

```java
// 인터페이스의 좋은 예
public interface Exporter {
  String export(SummaryStatistics summaryStatistics);
}
```

- 반환한 String을 이용해 출력하거나, 파일에 저장하거나, 어딘가로 전송할 수 있다.
- Assertion으로 직접 비교할 수 있으므로 쉽게 테스트할 수 있다.

인터페이스를 준수하는 내보내기 기능 구현(예제3-15)

```java
public class HtmlExporter implements Exporter {
  @Override
  public String export(final SummaryStatistics summaryStatistics) {
    String result = "<!doctype html>";
    result += "<html lang='en'>";
    result += "<head><title>Bank Transaction Report</title></head>";
    result += "<body>";
    result += "<ul>";
    result += "<li><strong>The sum is</strong>: " + summaryStatistics.getSum() + "</li>";
    result += "<li><strong>The average is</strong>: " + summaryStatistics.getAverage() + "</li>";
    result += "<li><strong>The max is</strong>: " + summaryStatistics.getMax() + "</li>";
    result += "<li><strong>The min is</strong>: " + summaryStatistics.getMin() + "</li>";
    result += "</ul>";
    result += "</body>";
    result += "</html>";
    return result;
  }
}
```



## 예외 처리

### 예외를 사용해야 하는 이유

고전적인 C 프로그래밍 - 수많은 if 조건을 추가하여 오류 코드를 반환하는 방법의 여러 단점

- 전역으로 공유된 가변 상태에 의존해 최근에 발생한 오류를 검색해야 한다.
- 코드 부분이 따로 분리되어 이해하기가 어려워진다.
- 코드를 유지보수하기 어렵다.
- 어떤 값이 실제 값인지 아니면 오류를 가리키는 값인지 구분하기 어렵다.
- 제어 흐름이 비즈니스 로직과 섞이면서 코드를 유지보수하거나 프로그램의 일부를 따로 테스트하기도 어려워진다.

자바 - 예외를 일급 언어 기능으로 추가, 장점 제공

- 문서화 : 메서드 시그니처 자체에 예외를 지원한다.
- 형식 안전성 : 개발자가 예외 흐름을 처리하고 있는지를 형식 시스템이 파악한다.
- 관심사 분리 : 비즈니스 로직과 예외 회복이 각각 try/catch 블록으로 구분된다.
- 단점 - 예외 기능으로 복잡성이 증가한다.

두 가지 종류의 예외

- 확인된 예외 : 회복해야 하는 대상의 예외. 프로그램에서 잡아 회복해야 하는 오류를 가리킨다.
- 미확인 예외 : 언제든 발생할 수 있는 종류의 예외. 보통 이런 오류는 잡지 않는다.

### 예외의 패턴과 안티 패턴

어떤 상황에 어떤 종류의 예외를 사용해야 할까? -> 정해진 답은 따로 없다. 상황에 따라 달라진다.

- 보통 비즈니스 로직 검증(잘못된 형식이나 연산 등) 시 발생한 문제는 불필요한 try/catch 구문을 줄일 수 있도록 미확인 예외로 결정한다.
- 예외가 발생했을 때 응용프로그램을 어떻게 회복시킬 것인지 애매한 상황 -> API 사용자에게 오류를 복구하라고 강제할 필요가 없다.
- 시스템 오류 -> 미확인 예외

대다수 예외를 미확인 예외로 지정하고 꼭 필요한 상황에서만 확인된 예외로 지정해 불필요한 코드를 줄여야 한다.

#### 안티 패턴 1 - 과도하게 세밀함

입력에서 발생할 수 있는 모든 경계 상황을 고려하고, 각각의 경계 상황을 별도의 확인된 예외로 변환한다. (에제3-18)

- 각각의 예외에 적합하고 정확한 회복기법을 구현할 수 있다.
- 너무 많은 설정 작업이 필요하다.
- 여러 예외를 선언해야 한다.
- 사용자가 모든 예외를 처리해야 하므로 생산성이 현저하게 떨어진다.
- 사용자가 API를 쉽게 사용할 수 없게 된다.
- 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수도 없다.

#### 안티 패턴 2 - 과도하게 덤덤함

모든 예외를 `IllegalArgumentException` 등의 미확인 예외로 지정한다. (예제3-19)

- 전부 동일한 예외로 지정하면 구체적인 회복 로직을 만들 수 없다.
- 여러 오류가 발생했을 때 모든 오류 목록을 모아 사용자에게 제공할 수 없다.

#### 해결책 - 노티피케이션 패턴

너무 많은 미확인 예외를 사용하는 상황에 적합한 해결책을 제공한다. 

- 도메인 클래스로 오류를 수집한다. (예제3-20)

한 번에 여러 오류를 수집할 수 있는 검증자를 만든다. (예제3-21)

### 예외 사용 가이드라인

응용프로그램에서 예외를 사용하는 일반적인 가이드라인

- 예외를 무시하지 않음
  - 예외를 처리할 수 있는 방법이 명확하지 않으면 미확인 예외를 대신 던진다.
- 일반적인 예외는 잡지 않음 
  - 가능한 구체적으로 예외를 잡으면 가독성이 높아지고 더 세밀하게 예외를 처리할 수 있다.
- 예외 문서화 
  - API 수준에서 미확인 예외를 포함한 예외를 문서화하므로 API 사용자에게 문제 해결의 실마리를 제공한다.
- 특정 구현에 종속된 예외를 주의할 것 
  - 특정 구현에 종속된 예외를 던지면 API의 캡슐화가 깨지므로 주의해야한다.
- 예외 vs 제어흐름 
  - 예외로 흐름을 제어하지 않는다.

### 예외 대안 기능

예외를 대체할 만한 다양한 기능과 장단점

- null 사용

  - 절대 X
  - null은 호출자에게 아무 정보도 제공하지 않는다.
  - 오류 쉽게 발생, 불필요한 디버깅 시간 소비

- null 객체 패턴

  - 객체가 존재하지 않을 때 null 레퍼런스를 반환하는 대신에 필요한 인터페이스를 구현하는 객체를 반환하는 기법
  - 장점 : 의도하지 않은 `NullPointerException`과 긴 null 확인 코드를 피할 수 있다.
  - 단점 : 데이터에 문제가 있어도 빈 객체를 이용해 실제 문제를 무시할 수 있어 나중에 문제를 해결하기가 더 어려워질 수 있다.

- Optional\<T>

  - 값이 없는 상태를 명시적으로 처리하는 다양한 메서드 집합을 제공 -> 버그의 범위를 줄이는 데 큰 도움이 된다.
  - 다양한 Optional 객체를 조합할 수 있어 다른 API에서 반환한 Optional 형식을 다른 Optional 형식과 조합할 수 있다.

- Try\<T>

  - 성공하거나 실패할 수 있는 연산을 가리킨다.

  - 값이 아니라 연산에 적용한다.

  - 코드 조합성의 장점을 제공한다.

  - 코드에서 발생하는 오류 범위를 줄여준다.

  - 외부 라이브러리를 이용해야한다.

    > 외부 라이브러리를 이용하면 결합도가 증가해서 좋은 방법은 아닌거 같다.



## 빌드 도구 사용

빌드 도구를 사용의 장점

- 프로젝트에 적용되는 공통적인 구조를 제공하기 때문에 동료 개발자가 프로젝트를 좀 더 편안하게 받아들인다.
- 응용프로그램을 빌드하고 실행하는 반복적이고, 표준적인 작업을 설정한다.
- 저수준 설정과 초기화에 들이는 시간을 절약하므로 개발에만 집중할 수 있다.
- 잘못된 설정이나 일부 빌드 과정 생략 등으로 발생하는 오류의 범위를 줄인다.
- 공통 빌드 작업을 재사용해 이를 다시 구현할 필요가 없으므로 시간을 절약한다.

두 가지 빌드 도구

- 메이븐
  - XML 기반
  - pom.xml 파일
- 그레이들
  - 구조 표준화 등 여러 유용한 아이디어 계승
  - 도메인 특화 언어(DSL)을 적용
  - 더 자연스럽게 빌드를 지정한다.
  - 쉽게 커스터마이즈할 수 있다.
  - 쉽게 이해할 수 있다.
  - 빌드 시간을 단축하는 기능도 지원한다.
  - build.gradle 파일, settings.gradle 파일